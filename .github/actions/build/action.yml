name: Build
description: Build a Dockerfile

inputs:
  label:
    description: "Optional build suffix, e.g. 'dev'"
    type: string
    required: false
  repos:
    description: "Newline-separated list of <registry>/<repository> used to build refs"
    type: string
    required: false
  upstream-ref:
    description: "Upstream ref (tag or branch) to build"
    type: string
    required: true

outputs:
  repos:
    description: "Newline-separated list of <registry>/<repository> used to build refs"
    value: ${{ steps.compute.outputs.repos }}
  tags:
    description: "Newline-separated list of built tags"
    value: ${{ steps.compute.outputs.tags }}
  refs:
    description: "Newline-separated list of fully-qualified built image refs (repository:tag)"
    value: ${{ steps.compute.outputs.refs }}
  primary-tag:
    description: "Primary image tag (without repository)"
    value: ${{ steps.compute.outputs.primary-tag }}
  primary-ref:
    description: "First fully-qualified image reference produced by this build"
    value: ${{ steps.compute.outputs.primary-ref }}
  imageid:
    description: "Built image ID"
    value: ${{ steps.build.outputs.imageid }}
  digest:
    description: "Built image digest"
    value: ${{ steps.build.outputs.digest }}
  metadata:
    description: "Built image metadata"
    value: ${{ steps.build.outputs.metadata }}

runs:
  using: composite
  steps:
    - name: Compute tags and refs
      id: compute
      shell: bash -euo pipefail {0}
      env:
        SOURCE_REF: ${{ inputs.upstream-ref }}
        LABEL: ${{ inputs.label }}
        REPOS: ${{ inputs.repos }}
        REPOSITORY_NAME: ${{ github.repository }}
      run: |
        sanitize() {
          printf '%s' "$1" \
            | tr '[:upper:]' '[:lower:]' \
            | sed 's/[^a-z0-9._-]/-/g' \
            | sed 's/-\{2,\}/-/g; s/^-\|-$//g'
        }

        ref_for_slug="${SOURCE_REF}"
        case "${ref_for_slug}" in
          refs/heads/*) ref_for_slug="${ref_for_slug#refs/heads/}" ;;
          refs/tags/*) ref_for_slug="${ref_for_slug#refs/tags/}" ;;
          refs/*) ref_for_slug="${ref_for_slug#refs/}" ;;
        esac

        ref_slug="$(sanitize "${ref_for_slug}")"
        label_slug="$(sanitize "${LABEL}")"

        base_tag="${ref_slug}"
        if [ -n "${label_slug}" ]; then
          base_tag="${base_tag}-${label_slug}"
        fi

        if [ -z "${base_tag}" ]; then
          base_tag="build"
        fi

        tags=("${base_tag}")

        run_tag="${base_tag}-${GITHUB_RUN_ID}.${GITHUB_RUN_ATTEMPT}"
        tags+=("${run_tag}")

        mapfile -t repo_list < <(
          printf '%s' "${REPOS:-}" \
            | sed 's/\\r//g' \
            | sed 's/\\n/\n/g' \
            | sed '/^\s*$/d'
        )

        if ((${#repo_list[@]} == 0)); then
          repo_list=("local/${REPOSITORY_NAME#*/}")
        fi

        refs=()
        for repo in "${repo_list[@]:-}"; do
          repo="$(printf '%s' "$repo" | xargs)"
          [ -z "${repo}" ] && continue
          for tag in "${tags[@]}"; do
            refs+=("${repo}:${tag}")
          done
        done

        primary_ref="${refs[0]}"

        {
          printf 'tags<<EOF\n%s\nEOF\n' "$(printf '%s\n' "${tags[@]}")"
          printf 'refs<<EOF\n%s\nEOF\n' "$(printf '%s\n' "${refs[@]}")"
          printf 'repos<<EOF\n%s\nEOF\n' "$(printf '%s\n' "${repo_list[@]}")"
          printf 'primary-tag=%s\n' "${base_tag}"
          printf 'primary-ref=%s\n' "${primary_ref}"
          printf 'ref-slug=%s\n' "${ref_slug}"
        } >> "$GITHUB_OUTPUT"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver: docker

    - name: Build image
      id: build
      uses: docker/build-push-action@v6
      with:
        context: .
        push: false
        load: true
        build-args: |
          UPSTREAM_REF=${{ inputs.upstream-ref }}
        tags: ${{ steps.compute.outputs.refs }}
